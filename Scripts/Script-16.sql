
--IN 파라미터 변수 : 프로시져로 들어오는 데이터를 저장할 변수, 모드 기본값

CREATE OR REPLACE PROCEDURE PROC_DEPT30
(P_DID IN DEPARTMENTS.DEPARTMENT_ID%TYPE)
IS 
	CURSOR CUR_DEPT30 IS
	SELECT DEPARTMENT_ID DID, DEPARTMENT_NAME DNAME 
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = P_DID;
BEGIN 
	FOR ROW_DEPT IN CUR_DEPT30 LOOP	
		DBMS_OUTPUT.PUT_LINE(ROW_DEPT.DID||' '||ROW_DEPT.DNAME);
	END LOOP;
END;

DROP PROCEDURE PROC_DEPT30;

BEGIN
	PROC_DEPT30(60);
END;

SELECT * FROM DEPARTMENTS;



--OUT모드 파라미터 변수 : 프로시져에서 나가는 데이터를 저장할 변수

CREATE OR REPLACE PROCEDURE PROC_GET_DNAME
(DID IN DEPARTMENTS.DEPARTMENT_ID%TYPE,
DNAME OUT DEPARTMENTS.DEPARTMENT_NAME%TYPE)
IS 
BEGIN
	SELECT DEPARTMENT_NAME INTO DNAME
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = DID;
END;

DROP PROCEDURE PROC_GET_DNAME;

DECLARE
	V_DNAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;
BEGIN
	PROC_GET_DNAME(30,V_DNAME);
	DBMS_OUTPUT.PUT_LINE(V_DNAME);
END;

--IN OUT모드 파라미터 변수: 프로시져로 데이터가 들어오기도 하고 나가기도 하는 변수

CREATE OR REPLACE PROCEDURE PROC_INOUT
(V_DID IN OUT DEPARTMENTS.DEPARTMENT_ID%TYPE)
IS 
BEGIN
	SELECT DEPARTMENT_ID INTO V_DID
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = V_DID;
END;

DECLARE
	V_DID DEPARTMENTS.DEPARTMENT_ID%TYPE;
BEGIN
	V_DID := 50;
	PROC_INOUT(V_DID);
	DBMS_OUTPUT.PUT_LINE(V_DID);
END;


--FUNCTION(함수)
-- 함수는 IN파라미터 밖에 사용하지 못함
-- 함수는 리턴 탕비, 리턴 값이 있다.
--함수는 보통 쿼리문 내에서 사용한다
--오라클내에 만들어져 있는 내장 함수와 사용자가 만드는 사용자 정의 함수가 있다.

--직원아이디에 해당하는 면봉(SAL*12)을 반환하는 함수
CREATE OR REPLACE FUNCTION FUNC_YEAR_SAL
(EID IN EMPLOYEES.EMPLOYEE_ID%TYPE)
RETURN NUMBER 
IS
	ESAL EMPLOYEES.SALARY%TYPE;
BEGIN
	SELECT SALARY*12 INTO ESAL
	FROM EMPLOYEES
    WHERE EMPLOYEE_ID = EID;
	RETURN ESAL;
END;

DROP FUNCTION FUNC_YEAR_SAL;

SELECT FUNC_YEAR_SAL(110) FROM DUAL;

--실습) 두 수를 입력하면 합계를 리턴하는 함수를 만들어 테스트

CREATE OR REPLACE FUNCTION FUNC_ADD
(V_NUM1 NUMBER, V_NUM2 NUMBER)
RETURN NUMBER
IS  
BEGIN 
	RETURN V_NUM1 + V_NUM2;
END;

SELECT FUNC_ADD(10,20)FROM DUAL;



--패키지 생성

CREATE OR REPLACE PACKAGE PKG_HR
IS 
	PROCEDURE PROC_DEPT30
	(P_DID IN DEPARTMENTS.DEPARTMENT_ID%TYPE);

	PROCEDURE PROC_GET_DNAME
	(DID IN DEPARTMENTS.DEPARTMENT_ID%TYPE,
	 DNAME OUT DEPARTMENTS.DEPARTMENT_NAME%TYPE);

	PROCEDURE PROC_INOUT
	(V_DID IN OUT DEPARTMENTS.DEPARTMENT_ID%TYPE);

	FUNCTION FUNC_YEAR_SAL
	(EID IN EMPLOYEES.EMPLOYEE_ID%TYPE)
	RETURN NUMBER; 

	FUNCTION FUNC_ADD
	(V_NUM1 NUMBER, V_NUM2 NUMBER)
	 RETURN NUMBER;
END;





DROP PACKAGE PKG_HR;

DROP PACKAGE BODY PKG_HR;










CREATE OR REPLACE PACKAGE BODY PKG_HR
IS
PROCEDURE PROC_DEPT30
(P_DID IN DEPARTMENTS.DEPARTMENT_ID%TYPE)
IS 
	CURSOR CUR_DEPT30 IS
	SELECT DEPARTMENT_ID DID, DEPARTMENT_NAME DNAME 
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = P_DID;
BEGIN 
	FOR ROW_DEPT IN CUR_DEPT30 LOOP	
		DBMS_OUTPUT.PUT_LINE(ROW_DEPT.DID||' '||ROW_DEPT.DNAME);
	END LOOP;
END;

PROCEDURE PROC_GET_DNAME
(DID IN DEPARTMENTS.DEPARTMENT_ID%TYPE,
DNAME OUT DEPARTMENTS.DEPARTMENT_NAME%TYPE)
IS 
BEGIN
	SELECT DEPARTMENT_NAME INTO DNAME
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = DID;
END;

PROCEDURE PROC_INOUT
(V_DID IN OUT DEPARTMENTS.DEPARTMENT_ID%TYPE)
IS 
BEGIN
	SELECT DEPARTMENT_ID INTO V_DID
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = V_DID;
END;

FUNCTION FUNC_YEAR_SAL
(EID IN EMPLOYEES.EMPLOYEE_ID%TYPE)
RETURN NUMBER 
IS
	ESAL EMPLOYEES.SALARY%TYPE;
BEGIN
	SELECT SALARY*12 INTO ESAL
	FROM EMPLOYEES
    WHERE EMPLOYEE_ID = EID;
	RETURN ESAL;
END;

FUNCTION FUNC_ADD
(V_NUM1 NUMBER, V_NUM2 NUMBER)
RETURN NUMBER
IS  
BEGIN 
	RETURN V_NUM1 + V_NUM2;
END;
END;

SELECT PKG_HR.FUNC_ADD(20,30)FROM DUAL;





--HR

--TRIGGER (실습
-- JOBS 테이블에 INSERT할때 최저월급 보다 적은 월급이 아니어야 하고,
-- 전체 최고 월급보다 높은 월급이 아닌 데이터가 입력되도록 트리거 작성


SELECT MIN(MIN_SALARY),MAX(MAX_SALARY)FROM JOBS;




--시퀀스

DROP SEQUENCE SEQ_SAL;

DROP TRIGGER TRG_SAL;

CREATE OR REPLACE TRIGGER TRG_SAL
BEFORE
INSERT ON JOBS
FOR EACH ROW
DECLARE
   MINSAL JOBS.MIN_SALARY%TYPE;
   MAXSAL JOBS.MAX_SALARY%TYPE;
BEGIN
   SELECT MIN(MIN_SALARY), MAX(MAX_SALARY) INTO MINSAL, MAXSAL
   FROM JOBS;
   IF INSERTING THEN
      IF :NEW.MIN_SALARY < MINSAL THEN
         RAISE_APPLICATION_ERROR(-20000, '너무 낮은 급여')   ;
      END IF;
      IF :NEW.MAX_SALARY > MAXSAL THEN
         RAISE_APPLICATION_ERROR(-20001, '너무 높은 급여')   ;
      END IF;
   END IF;
END;

INSERT INTO JOBS VALUES('ID01', 'FISHER', 3000, 30000);
INSERT INTO JOBS VALUES('ID02', 'FISHER', 5000, 30000);

SELECT * FROM JOBS;









 






































